name: Guard Secrets
on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1) Hard block: .env must never be tracked
      - name: Block .env file
        run: |
          if git ls-files --error-unmatch .env >/dev/null 2>&1; then
            echo "::error title=.env detected::.env must never be committed."
            exit 1
          fi

      # 2) Build a list of changed files (vs. remote main)
      - name: Get changed files
        id: diff
        shell: bash
        run: |
          git fetch origin main:origin_main || true
          base=$(git merge-base HEAD origin_main || echo "")
          if [ -n "$base" ]; then
            CHANGED=$(git diff --name-only "$base"...HEAD | tr '\n' ' ')
          else
            CHANGED=$(git ls-files | tr '\n' ' ')
          fi
          echo "changed=$CHANGED" >> $GITHUB_OUTPUT

      # 3) Scan only changed files, ignore examples and workflows
      - name: Scan for obvious secrets in changed files
        if: steps.diff.outputs.changed != ''
        shell: bash
        run: |
          set -e
          # ignore example/templates and CI
          IGNORE='(:!*.example) (:!.github/**)'
          # Only scan env-like assignments with a non-empty value
          PATTERN='^(TELEGRAM_BOT_TOKEN|COINBASE_API_KEY|COINBASE_API_SECRET|COINBASE_API_PASSPHRASE|OPENAI_API_KEY)[[:space:]]*=[[:space:]]*[^#[:space:]]'
          files=(${ { steps.diff.outputs.changed } })
          # Filter out deleted files
          files=($(printf "%s\n" "${files[@]}" | xargs -I{} bash -lc '[ -f "{}" ] && echo "{}"' ))
          if [ ${#files[@]} -gt 0 ]; then
            bad=$(git grep -nE "$PATTERN" -- "${files[@]}" ':!*.example' ':!.github/**' || true)
            if [ -n "$bad" ]; then
              echo "::error title=Possible secrets found::$bad"
              exit 1
            fi
          fi
